From 79db7211d116754a85e797900cad17d1f0b32345 Mon Sep 17 00:00:00 2001
From: Vladimir Lelicanin <v.lelicanin@sae.edu>
Date: Sun, 6 May 2018 13:58:28 +0200
Subject: [PATCH 15/22] fix/testing-the-flow (#103)

Fixes the flow- based on events not on time
---
 migrations/20180502220705-create-event.js          |  36 +++
 models/event.js                                    |  14 ++
 modules/Blockchain.js                              |  34 ++-
 modules/Blockchain/Ethereum/Transactions.js        |  19 ++
 .../Blockchain/Ethereum/bidding-contract/abi.json  | 124 ++++++----
 modules/Blockchain/Ethereum/contracts/Bidding.sol  |  50 ++--
 modules/Blockchain/Ethereum/index.js               | 117 ++++++++--
 modules/DCService.js                               | 126 +++-------
 modules/DHService.js                               | 253 ++++++---------------
 modules/EventHandlers.js                           |   6 +-
 modules/Network.js                                 |   9 +-
 modules/Utilities.js                               |  14 +-
 ot-node.js                                         |   8 +
 package.json                                       |   5 +-
 seeders/20180420143224-node-config.js              |   4 +-
 15 files changed, 427 insertions(+), 392 deletions(-)
 create mode 100644 migrations/20180502220705-create-event.js
 create mode 100644 models/event.js

diff --git a/migrations/20180502220705-create-event.js b/migrations/20180502220705-create-event.js
new file mode 100644
index 0000000..1d8ee77
--- /dev/null
+++ b/migrations/20180502220705-create-event.js
@@ -0,0 +1,36 @@
+
+module.exports = {
+    up: (queryInterface, Sequelize) => queryInterface.createTable('events', {
+        id: {
+            allowNull: false,
+            autoIncrement: true,
+            primaryKey: true,
+            type: Sequelize.INTEGER,
+        },
+        event: {
+            type: Sequelize.STRING,
+        },
+        data: {
+            type: Sequelize.TEXT,
+        },
+        block: {
+            type: Sequelize.INTEGER,
+        },
+
+        dataId: {
+            type: Sequelize.INTEGER,
+        },
+        finished: {
+            type: Sequelize.STRING,
+        },
+        createdAt: {
+            allowNull: false,
+            type: Sequelize.DATE,
+        },
+        updatedAt: {
+            allowNull: false,
+            type: Sequelize.DATE,
+        },
+    }),
+    down: (queryInterface, Sequelize) => queryInterface.dropTable('Events'),
+};
diff --git a/models/event.js b/models/event.js
new file mode 100644
index 0000000..e8d58d8
--- /dev/null
+++ b/models/event.js
@@ -0,0 +1,14 @@
+
+module.exports = (sequelize, DataTypes) => {
+    var Event = sequelize.define('events', {
+        event: DataTypes.STRING,
+        data: DataTypes.TEXT,
+        dataId: DataTypes.INTEGER,
+        block: DataTypes.INTEGER,
+        finished: DataTypes.STRING,
+    }, {});
+    Event.associate = function (models) {
+    // associations can be defined here
+    };
+    return Event;
+};
diff --git a/modules/Blockchain.js b/modules/Blockchain.js
index b1783e8..029217e 100644
--- a/modules/Blockchain.js
+++ b/modules/Blockchain.js
@@ -118,17 +118,23 @@ class Blockchain {
     }
 
     /**
-     * Subscribe to a particular event
-     * @param contractName   Ethereum contract instance
-     * @param event          Event name
-     * @param eventOpts      Event options (filter, range, etc.)
-     * @param callback       Callback to be executed on success/error (callback returns stop flag)
-     * @param periodMills    Repeating period for checking past events
-     * @param untilMills     Subscription termination
+    * Subscribe to a particular event
+    * @param event
+    * @param dataId
+    * @param endMs
+    */
+    subscribeToEvent(event, dataId, endMs) {
+        return this.blockchain
+            .subscribeToEvent(event, dataId, endMs);
+    }
+
+    /**
+     * Gets all past events for the contract
+     * @param contractName
      */
-    subscribeToEvent(contractName, event, eventOpts, callback, periodMills, untilMills) {
+    getAllPastEvents(contractName) {
         return this.blockchain
-            .subscribeToEvent(contractName, event, eventOpts, callback, periodMills, untilMills);
+            .getAllPastEvents(contractName);
     }
 
     /**
@@ -191,6 +197,16 @@ class Blockchain {
     getBid(dcWallet, dataId, bidIndex) {
         return this.blockchain.getBid(dcWallet, dataId, bidIndex);
     }
+
+    /**
+    * Gets status of the offer
+    * @param dcWallet
+    * @param dataId
+    * @return {Promise<any>}
+    */
+    getOfferStatus(dcWallet, dataId) {
+        return this.blockchain.getOfferStatus(dcWallet, dataId);
+    }
 }
 
 module.exports = Blockchain;
diff --git a/modules/Blockchain/Ethereum/Transactions.js b/modules/Blockchain/Ethereum/Transactions.js
index 30f8ba3..8bd3af6 100644
--- a/modules/Blockchain/Ethereum/Transactions.js
+++ b/modules/Blockchain/Ethereum/Transactions.js
@@ -37,6 +37,7 @@ class Transactions {
             newTransaction.args,
             newTransaction.options,
         );
+
         const transaction = new Tx(rawTx);
         transaction.sign(this.privateKey);
 
@@ -103,6 +104,24 @@ class Transactions {
                 });
         }));
     }
+
+    /**
+    * Get the value from getter
+    * @param contract
+    * @param functionName
+    * @param functionParameters
+    * @return {Promise<string>}
+    */
+    getValue(contract, functionName, functionParameters) {
+        console.log(contract);
+        var callData = contract.methods.cancelBid.call(0, (err, res) => {
+            console.log(res);
+        });
+        // return this.web3.eth.call({
+        //     to: this.walletAddress,
+        //     data: callData,
+        // });
+    }
 }
 
 module.exports = Transactions;
diff --git a/modules/Blockchain/Ethereum/bidding-contract/abi.json b/modules/Blockchain/Ethereum/bidding-contract/abi.json
index 93561b0..2479a83 100644
--- a/modules/Blockchain/Ethereum/bidding-contract/abi.json
+++ b/modules/Blockchain/Ethereum/bidding-contract/abi.json
@@ -137,26 +137,38 @@
     "type": "function"
   },
   {
-    "anonymous": false,
+    "constant": false,
     "inputs": [
       {
-        "indexed": false,
         "name": "DC_wallet",
         "type": "address"
       },
       {
-        "indexed": false,
-        "name": "DH_wallet",
-        "type": "address"
+        "name": "data_id",
+        "type": "uint256"
       },
       {
-        "indexed": false,
-        "name": "data_id",
+        "name": "node_id",
+        "type": "uint256"
+      },
+      {
+        "name": "token_amount",
+        "type": "uint256"
+      },
+      {
+        "name": "stake_amount",
+        "type": "uint256"
+      },
+      {
+        "name": "bidIndex",
         "type": "uint256"
       }
     ],
-    "name": "BidTaken",
-    "type": "event"
+    "name": "revealBid",
+    "outputs": [],
+    "payable": false,
+    "stateMutability": "nonpayable",
+    "type": "function"
   },
   {
     "anonymous": false,
@@ -213,38 +225,16 @@
     "type": "event"
   },
   {
-    "constant": false,
+    "anonymous": false,
     "inputs": [
       {
-        "name": "DC_wallet",
-        "type": "address"
-      },
-      {
-        "name": "data_id",
-        "type": "uint256"
-      },
-      {
-        "name": "node_id",
-        "type": "uint256"
-      },
-      {
-        "name": "token_amount",
-        "type": "uint256"
-      },
-      {
-        "name": "stake_amount",
-        "type": "uint256"
-      },
-      {
-        "name": "bidIndex",
+        "indexed": false,
+        "name": "x",
         "type": "uint256"
       }
     ],
-    "name": "revealBid",
-    "outputs": [],
-    "payable": false,
-    "stateMutability": "nonpayable",
-    "type": "function"
+    "name": "XwasSet",
+    "type": "event"
   },
   {
     "anonymous": false,
@@ -260,7 +250,7 @@
         "type": "uint256"
       }
     ],
-    "name": "OfferCanceled",
+    "name": "ChoosingPhaseStarted",
     "type": "event"
   },
   {
@@ -310,6 +300,45 @@
       },
       {
         "indexed": false,
+        "name": "DH_wallet",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "name": "data_id",
+        "type": "uint256"
+      }
+    ],
+    "name": "BidTaken",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": false,
+        "name": "DC_wallet",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "name": "data_id",
+        "type": "uint256"
+      }
+    ],
+    "name": "RevealPhaseStarted",
+    "type": "event"
+  },
+  {
+    "anonymous": false,
+    "inputs": [
+      {
+        "indexed": false,
+        "name": "DC_wallet",
+        "type": "address"
+      },
+      {
+        "indexed": false,
         "name": "DC_node_id",
         "type": "uint256"
       },
@@ -347,11 +376,16 @@
     "inputs": [
       {
         "indexed": false,
-        "name": "x",
+        "name": "DC_wallet",
+        "type": "address"
+      },
+      {
+        "indexed": false,
+        "name": "data_id",
         "type": "uint256"
       }
     ],
-    "name": "XwasSet",
+    "name": "OfferCanceled",
     "type": "event"
   },
   {
@@ -453,8 +487,8 @@
     "name": "getOfferStatus",
     "outputs": [
       {
-        "name": "isOfferFinal",
-        "type": "bool"
+        "name": "offerStatus",
+        "type": "uint8"
       }
     ],
     "payable": false,
@@ -551,12 +585,8 @@
         "type": "uint256"
       },
       {
-        "name": "active",
-        "type": "bool"
-      },
-      {
-        "name": "finalized",
-        "type": "bool"
+        "name": "bidding_phase",
+        "type": "uint8"
       }
     ],
     "payable": false,
diff --git a/modules/Blockchain/Ethereum/contracts/Bidding.sol b/modules/Blockchain/Ethereum/contracts/Bidding.sol
index e0501d8..a5ceb2f 100644
--- a/modules/Blockchain/Ethereum/contracts/Bidding.sol
+++ b/modules/Blockchain/Ethereum/contracts/Bidding.sol
@@ -61,6 +61,7 @@ contract Bidding {
 
 	/*    ----------------------------- BIDDING -----------------------------     */
 
+	enum BiddingPhase {initialised, bidding, revealing, choosing, completed, cancelled}
 
 	struct OfferDefinition{
 		//Parameters of one escrow
@@ -68,7 +69,7 @@ contract Bidding {
 		uint max_token_amount;
 		uint min_stake_amount;
 
-		//Parameters for the bidding 
+		//Parameters for the bidding
 		uint reveal_start_time;
 		uint choose_start_time;
 		uint min_number_of_bids;
@@ -83,8 +84,7 @@ contract Bidding {
 		uint256 number_of_bids_revealed;
 		uint total_bid_chance;
 		uint random_number_seed;
-		bool active;
-		bool finalized;
+		BiddingPhase bidding_phase;
 	}
 
 	struct BidDefinition{
@@ -103,10 +103,10 @@ contract Bidding {
 
 	uint256 x;
 
-	event OfferCreated(address DC_wallet,uint DC_node_id, uint data_id, uint total_escrow_time, uint max_token_amount, uint min_stake_amount, uint data_size);
+	event OfferCreated(address DC_wallet, uint DC_node_id, uint data_id, uint total_escrow_time, uint max_token_amount, uint min_stake_amount, uint data_size);
 	event OfferCanceled(address DC_wallet, uint data_id);
-	// event RevealPhaseStarted(address DC_wallet, uint data_id);
-	// event ChoosingPhaseStarted(address DC_wallet, uint data_id);
+	event RevealPhaseStarted(address DC_wallet, uint data_id);
+	event ChoosingPhaseStarted(address DC_wallet, uint data_id);
 	event AddedBid(address DC_wallet,uint data_id, uint bidIndex, address DH_wallet, uint node_id, bytes32 bid_hash);
 	event BidTaken(address DC_wallet, address DH_wallet, uint data_id);
 	event RevealedBid(address DC_wallet, address DH_wallet,  uint node_id,uint data_id,  uint token_amount, uint stake_amount);
@@ -127,7 +127,6 @@ contract Bidding {
 
 		require(max_token_amount > 0 && total_escrow_time > 0 && min_number_of_bids > 0 && bidding_phase_time > 0 && replication_factor > 0);
 		require(replication_factor <= min_number_of_bids);
-		require(offer[msg.sender][data_id].active == false);
 
 		// require(token.allowance(msg.sender,this) >= SafeMath.mul(tokens_per_DH,replication_factor));
 		// token.transferFrom(msg.sender,this,SafeMath.mul(tokens_per_DH,replication_factor));
@@ -145,8 +144,7 @@ contract Bidding {
 
 		offer[msg.sender][data_id].number_of_bids = 0;
 		offer[msg.sender][data_id].number_of_bids_revealed = 0;
-		offer[msg.sender][data_id].active = true;
-		offer[msg.sender][data_id].finalized = false;
+		offer[msg.sender][data_id].bidding_phase = BiddingPhase.bidding;
 		OfferCreated(msg.sender, DC_node_id, data_id, total_escrow_time,max_token_amount, min_stake_amount, data_size);
 	}
 
@@ -154,22 +152,22 @@ contract Bidding {
 	//Da li vraca pare? Kada sme da uradi cancel?
 	function cancelOffer(uint data_id)
 	public{
-		offer[msg.sender][data_id].active = false;
-
+		offer[msg.sender][data_id].bidding_phase = BiddingPhase.cancelled;
 		OfferCanceled(msg.sender, data_id);
 	}
 
 	function isBidChosen(address DC_wallet, uint data_id, uint bidIndex) public constant returns (bool _isBidChosen){
 		return bid[DC_wallet][data_id][bidIndex].chosen;
 	}
-	function getOfferStatus(address DC_wallet, uint data_id) public constant returns (bool isOfferFinal){
-		return offer[DC_wallet][data_id].finalized;
+	function getOfferStatus(address DC_wallet, uint data_id) public constant returns (BiddingPhase offerStatus){
+		return offer[DC_wallet][data_id].bidding_phase;
 	}
 
 	function addBid(address DC_wallet, uint data_id, uint node_id, bytes32 bid_hash)
 	public returns (uint bidIndex){
-		require(offer[DC_wallet][data_id].active);
-		require(offer[DC_wallet][data_id].reveal_start_time > block.timestamp);
+		// require(offer[DC_wallet][data_id].active);
+		require(offer[DC_wallet][data_id].bidding_phase == BiddingPhase.bidding);
+//		require(offer[DC_wallet][data_id].reveal_start_time > block.timestamp);
 
 		bidIndex = offer[DC_wallet][data_id].number_of_bids;
 		offer[DC_wallet][data_id].number_of_bids = offer[DC_wallet][data_id].number_of_bids.add(1);
@@ -179,15 +177,19 @@ contract Bidding {
 
 		// bid[DC_wallet][data_id][bidIndex].bid_hash = keccak256(msg.sender, node_id, token_amount, stake_amount);
 		AddedBid(DC_wallet,data_id, bidIndex, msg.sender, node_id, bid_hash );
+
+		if(offer[DC_wallet][data_id].number_of_bids >= offer[DC_wallet][data_id].replication_factor){
+			offer[DC_wallet][data_id].bidding_phase = BiddingPhase.revealing;
+			RevealPhaseStarted(DC_wallet,data_id);
+		}
 		return bidIndex;
 	}
 
 	function revealBid(address DC_wallet, uint data_id, uint node_id, uint token_amount, uint stake_amount, uint bidIndex)
 	public {
 
-		require(offer[DC_wallet][data_id].active);
-		require(offer[DC_wallet][data_id].reveal_start_time <= block.timestamp);
-		require(offer[DC_wallet][data_id].choose_start_time > block.timestamp);
+		require(offer[DC_wallet][data_id].bidding_phase == BiddingPhase.revealing);
+//		require(offer[DC_wallet][data_id].choose_start_time > block.timestamp);
 		require(offer[DC_wallet][data_id].max_token_amount >= token_amount);
 
 		require(bid[DC_wallet][data_id][bidIndex].bid_hash == keccak256(msg.sender, node_id, token_amount, stake_amount));
@@ -197,7 +199,6 @@ contract Bidding {
 		bid[DC_wallet][data_id][bidIndex].token_amount = token_amount;
 		bid[DC_wallet][data_id][bidIndex].stake_amount = stake_amount;
 		bid[DC_wallet][data_id][bidIndex].chance = TOTAL_NUM_TOKENS / token_amount;
-		bid[DC_wallet][data_id][bidIndex].active = true;
 
 		OfferDefinition storage this_offer = offer[DC_wallet][data_id];
 
@@ -207,6 +208,11 @@ contract Bidding {
 
 		RevealedBid(DC_wallet,msg.sender, node_id,data_id, token_amount, stake_amount);
 
+		if(this_offer.number_of_bids_revealed >= this_offer.number_of_bids){
+			this_offer.bidding_phase = BiddingPhase.choosing;
+			ChoosingPhaseStarted(DC_wallet,data_id);
+		}
+
 	}
 
 	function cancelBid(address DC_wallet, uint data_id, uint bidIndex)
@@ -226,7 +232,9 @@ contract Bidding {
 		OfferDefinition storage this_offer = offer[msg.sender][data_id];
 
 		require(this_offer.min_number_of_bids <= this_offer.number_of_bids_revealed);
-		require(this_offer.choose_start_time <= block.timestamp);
+//		require(this_offer.choose_start_time <= block.timestamp);//
+
+		require(this_offer.bidding_phase == BiddingPhase.choosing);
 
 		uint N = this_offer.replication_factor;
 		chosen_data_holders = new uint256[](N);
@@ -273,7 +281,7 @@ contract Bidding {
 
 
 
-		offer[msg.sender][data_id].finalized = true;
+		offer[msg.sender][data_id].bidding_phase = BiddingPhase.completed;
 		OfferFinalized(msg.sender,data_id);
 
 	}
diff --git a/modules/Blockchain/Ethereum/index.js b/modules/Blockchain/Ethereum/index.js
index eb04269..75f0a21 100644
--- a/modules/Blockchain/Ethereum/index.js
+++ b/modules/Blockchain/Ethereum/index.js
@@ -3,6 +3,8 @@ const fs = require('fs');
 const Transactions = require('./Transactions');
 const Utilities = require('../../Utilities');
 const globalEvents = require('../../GlobalEvents');
+const SystemStorage = require('../../Database/SystemStorage');
+const Storage = require('../../Storage');
 
 const { globalEmitter } = globalEvents;
 
@@ -251,34 +253,80 @@ class Ethereum {
     }
 
     /**
-     * Subscribe to a particular event
-     * @param contractName   Ethereum contract instance
-     * @param event          Event name
-     * @param eventOpts      Event options (filter, range, etc.)
-     * @param callback       Callback to be executed on success/error (callback returns stop flag)
-     * @param periodMills    Repeating period for checking past events
-     * @param untilMills     Subscription termination
+     * Gets all past events for the contract
+     * @param contractName
      */
-    subscribeToEvent(contractName, event, eventOpts, callback, periodMills, untilMills) {
-        const looper = setInterval(() => {
-            if (untilMills < Date.now()) {
-                log.trace('Looper for event is going to be unsubscribed');
-                clearTimeout(looper);
-                return;
-            }
-            this.contractsByName[contractName].getPastEvents(event, eventOpts).then((events) => {
-                const stop = callback(events);
-                if (stop) {
-                    clearTimeout(looper);
-                }
+    getAllPastEvents(contractName) {
+        Utilities.getBlockNumberFromWeb3().then((currentBlockHex) => {
+            const currentBlock = Utilities.hexToNumber(currentBlockHex);
+            this.contractsByName[contractName].getPastEvents('allEvents', {
+                fromBlock: currentBlock - 10,
+                toBlock: 'latest',
+            }).then((events) => {
+                events.forEach((event) => {
+                    // TODO: make filters - we don't need to listen all events
+                    /* eslint-disable-next-line */
+                    if (event.event === 'OfferCreated' || 1 === 1) {
+                        Storage.db.query('INSERT INTO events(event,data, dataId, block, createdAt, updatedAt) \n' +
+                          'SELECT ?, ?, ?, ?, ?, ? \n' +
+                          'WHERE NOT EXISTS(SELECT 1 FROM events WHERE event = ? AND data = ?)', {
+                            replacements: [event.event,
+                                JSON.stringify(event.returnValues),
+                                event.returnValues.data_id,
+                                event.blockNumber,
+                                Date.now(),
+                                Date.now(),
+                                event.event,
+                                JSON.stringify(event.returnValues)],
+                        }).catch((err) => {
+                            console.log(err);
+                        });
+                    }
+                });
+
+                // Delete old events
+                Storage.db.query('DELETE FROM events WHERE block < ?', {
+                    replacements: [currentBlock - 10],
+                }).catch((err) => {
+                    console.log(err);
+                });
             }).catch((err) => {
-                log.error(`Failed to get past events for ${event}`);
-                const stop = callback(null, err);
-                if (stop) {
-                    clearTimeout(looper);
-                }
+                log.error('Failed to get past events');
+                console.log(err);
             });
-        }, periodMills);
+        });
+    }
+
+    /**
+    * Subscribes to blockchain events
+    * @param event
+    * @param dataId
+    * @param params
+    * @param endMs
+    */
+    subscribeToEvent(event, dataId, endMs = 5 * 60 * 1000) {
+        return new Promise((resolve, reject) => {
+            const token = setInterval(() => {
+                Storage.models.events.findOne({
+                    where: {
+                        event,
+                        dataId,
+                        finished: null,
+                    },
+                }).then((eventData) => {
+                    if (eventData) {
+                        globalEmitter.emit(event, eventData.dataValues);
+                        eventData.finished = true;
+                        eventData.save();
+                        clearInterval(token);
+                        resolve(JSON.parse(eventData.dataValues.data));
+                    }
+                });
+            }, 2000);
+            setTimeout(() => {
+                clearInterval(token);
+            }, endMs);
+        });
     }
 
     /**
@@ -391,6 +439,25 @@ class Ethereum {
     }
 
     /**
+    * Gets status of the offer
+    * @param dcWallet
+    * @param dataId
+    * @return {Promise<any>}
+    */
+    getOfferStatus(dcWallet, dataId) {
+        return new Promise((resolve, reject) => {
+            log.trace(`Asking for ${dataId} offer status`);
+            this.biddingContract.methods.getOfferStatus(dcWallet, dataId).call({
+                from: dcWallet,
+            }).then((res) => {
+                resolve(res);
+            }).catch((e) => {
+                reject(e);
+            });
+        });
+    }
+
+    /**
      * Normalizes Kademlia node ID
      * @param nodeId     Kademlia node ID
      * @returns {string} Normalized node ID
diff --git a/modules/DCService.js b/modules/DCService.js
index 3598ba2..34f504d 100644
--- a/modules/DCService.js
+++ b/modules/DCService.js
@@ -5,7 +5,6 @@ const Graph = require('./Graph');
 const Blockchain = require('./BlockChainInstance');
 const bytes = require('utf8-length');
 const BN = require('bn.js');
-const deasync = require('deasync-promise');
 const Utilities = require('./Utilities');
 const Models = require('../models');
 
@@ -14,12 +13,11 @@ const log = Utilities.getLogger();
 // TODO
 const totalEscrowTime = 10 * 60 * 1000;
 const replicationFactor = 1;
-const biddingTime = 100 * 1000;
+const biddingTime = 2 * 60 * 1000;
 const tenderDuration = biddingTime + 1000;
 const minNumberOfBids = 1;
 const minStakeAmount = new BN('100');
-const maxTokenAmount = new BN('10000000');
-
+const maxTokenAmount = new BN('1000');
 /**
  * DC operations (handling new offers, etc.)
  */
@@ -31,19 +29,8 @@ class DCService {
             console.log('Error: ', e);
         });
 
-        let price;
         const importSizeInBytes = new BN(this._calculateImportSize(vertices));
-        const availableFunds = deasync(Utilities.getAlphaTracTokenBalance());
-        const potentialPrice = `${Utilities.getRandomIntRange(1, 10).toString()}00`;
-
-        if (Number(potentialPrice) > Number(availableFunds)) {
-            // not enought funds in wallet, give all-in for a price
-            price = availableFunds;
-        } else {
-            // sufficient funds, go further
-            price = potentialPrice;
-        }
-
+        const price = `${Utilities.getRandomIntRange(1, 10).toString()}00`;
         Models.offers.create({
             id: dataId,
             data_lifespan: totalEscrowTime,
@@ -80,16 +67,14 @@ class DCService {
                     importSizeInBytes: importSizeInBytes.toString(),
                     replicationFactor,
                 });
-                log.trace('Started bidding time');
-                setTimeout(() => {
-                    log.trace(`Started reveal time ${Math.round(Date.now() / 1000)}`);
-                }, biddingTime);
-
-                setTimeout(() => {
-                    log.trace(`Started choose time ${Math.round(Date.now() / 1000)}`);
-                }, biddingTime * 2);
-
-                DCService.scheduleChooseBids(dataId, totalEscrowTime);
+                log.trace('Started bidding phase');
+                Blockchain.bc.subscribeToEvent('ChoosingPhaseStarted', dataId)
+                    .then((event) => {
+                        log.trace('Started choosing phase.');
+                        DCService.chooseBids(dataId, totalEscrowTime);
+                    }).catch((err) => {
+                        console.log(err);
+                    });
             }).catch((err) => {
                 log.warn(`Failed to create offer. ${JSON.stringify(err)}`);
             });
@@ -111,85 +96,36 @@ class DCService {
     }
 
     /**
-   * Schedule chose DHs
+   * Chose DHs
    * @param dataId            Data ID
    * @param totalEscrowTime   Total escrow time
    */
-    static scheduleChooseBids(dataId, totalEscrowTime) {
+    static chooseBids(dataId, totalEscrowTime) {
         Models.offers.findOne({ where: { id: dataId } }).then((offerModel) => {
             const offer = offerModel.get({ plain: true });
+            log.info(`Choose bids for data ${dataId}`);
+            Blockchain.bc.increaseApproval(offer.max_token_amount * offer.replication_number)
+                .then(() => {
+                    Blockchain.bc.chooseBids(dataId)
+                        .then(() => {
+                            log.info(`Bids chosen for data ${dataId}`);
+                        }).catch((err) => {
+                            log.warn(`Failed call choose bids for data ${dataId}. ${err}`);
+                        });
+                }).catch((err) => {
+                    log.warn(`Failed to increase allowance. ${JSON.stringify(err)}`);
+                });
 
-            function chooseBids(dataId) {
-                log.info(`Choose bids for data ${dataId}`);
-
-                Blockchain.bc.increaseApproval(offer.max_token_amount * offer.replication_number)
-                    .then(() => {
-                        Blockchain.bc.chooseBids(dataId)
-                            .then(() => {
-                                log.info(`Bids choose called for data ${dataId}`);
-
-                                Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'OfferFinalized', {
-                                    fromBlock: 0,
-                                    toBlock: 'latest',
-                                }, (data, err) => {
-                                    if (err) {
-                                        log.error(err);
-                                        return true;
-                                    }
-                                    // filter events manually since Web3 filtering is not working
-                                    for (const event of data) {
-                                        const eventDataId = event.returnValues.data_id;
-                                        const eventDcWallet = event.returnValues.DC_wallet;
-
-                                        if (Number(eventDataId) === dataId
-                                            && eventDcWallet === config.node_wallet) {
-                                            log.info(`Offer for data ${dataId} successfully finalized`);
-                                            DCService.handleFinalizedOffer(dataId);
-                                            return true;
-                                        }
-                                    }
-                                    return false;
-                                }, 5000, Date.now() + totalEscrowTime);
-                            }).catch((err) => {
-                                log.warn(`Failed call choose bids for data ${dataId}. ${err}`);
-                            });
-                    }).catch((err) => {
-                        log.warn(`Failed to increase allowance. ${JSON.stringify(err)}`);
-                    });
-            }
-            // change time period in order to test choose bids
-            setTimeout(chooseBids, 2 * offer.tender_duration, dataId);
+            Blockchain.bc.subscribeToEvent('OfferFinalized', dataId)
+                .then((event) => {
+                    log.info(`Offer for ${dataId} finalized`);
+                }).catch((error) => {
+                    log.error(`Failed to get offer (data ID ${dataId}). ${error}.`);
+                });
         }).catch((error) => {
             log.error(`Failed to get offer (data ID ${dataId}). ${error}.`);
         });
     }
-
-    /**
-   * Process finalized offer
-   * @param dataId    Data ID
-   */
-    static handleFinalizedOffer(dataId) {
-        Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'BidTaken', {
-            fromBlock: 0,
-            toBlock: 'latest',
-        }, (data, err) => {
-            if (err) {
-                log.error(err);
-                return true;
-            }
-            // filter events manually since Web3 filtering is not working
-            for (const event of data) {
-                const eventDataId = event.returnValues.data_id;
-                const eventDhWallet = event.returnValues.DH_wallet;
-                const eventDcWallet = event.returnValues.DC_wallet;
-
-                if (Number(eventDataId) === dataId && eventDcWallet === config.node_wallet) {
-                    log.info(`The bid is chosen for DH ${eventDhWallet} and data ${dataId}`);
-                }
-            }
-            return true;
-        }, 5000, Date.now() + 20000);
-    }
 }
 
 module.exports = DCService;
diff --git a/modules/DHService.js b/modules/DHService.js
index 7d1c36d..d91eb1f 100644
--- a/modules/DHService.js
+++ b/modules/DHService.js
@@ -55,64 +55,93 @@ class DHService {
 
             const bidHash = abi.soliditySHA3(
                 ['address', 'uint', 'uint', 'uint'],
-                [config.node_wallet, new BN(config.identity, 16), chosenPrice, stake],
+                [config.node_wallet, `0x${config.identity}`, chosenPrice, stake],
             ).toString('hex');
 
             log.trace(`Adding a bid for DC wallet ${dcWallet} and data ID ${dataId} hash ${bidHash}`);
+
             Blockchain.bc.addBid(dcWallet, dataId, config.identity, `0x${bidHash}`)
-                .then((tx) => {
-                // Sign escrow.
-                    Blockchain.bc.increaseBiddingApproval(stake).catch(error => log.error(`Failed to increase approval. ${error}.`));
-                    log.trace('Bidding approval increased');
-                    Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'AddedBid', {
-                        fromBlock: 0,
-                        toBlock: 'latest',
-                    }, (data, err) => {
-                        if (err) {
-                            log.error(err);
-                            return true;
-                        }
-                        // filter events manually since Web3 filtering is not working
-                        for (const event of data) {
-                            const eventDataId = event.returnValues.data_id;
-                            const eventDhWallet = event.returnValues.DH_wallet;
+                .then(Blockchain.bc.increaseBiddingApproval(stake))
+                .catch(error => log.error(`Failed to add bid. ${error}.`));
+            let bid_index;
+            Blockchain.bc.subscribeToEvent('AddedBid', dataId)
+                .then((event) => {
+                    bid_index = event.bidIndex;
+                    this._saveBidToStorage(
+                        event,
+                        dcNodeId,
+                        chosenPrice,
+                        totalEscrowTime,
+                        stake,
+                        dataSizeBytes,
+                        dataId,
+                    );
+                }).catch((err) => {
+                    console.log(err);
+                });
 
-                            if (Number(eventDataId) === dataId
-                  && eventDhWallet === config.node_wallet) {
-                                const { bidIndex } = event.returnValues;
-                                Models.bids.create({
-                                    bid_index: bidIndex,
-                                    price: chosenPrice.toString(),
-                                    data_id: dataId,
-                                    dc_wallet: dcWallet,
-                                    dc_id: dcNodeId,
-                                    hash: bidHash,
-                                    total_escrow_time: totalEscrowTime.toString(),
-                                    stake: stake.toString(),
-                                    data_size_bytes: dataSizeBytes.toString(),
-                                }).then((bid) => {
-                                    log.info(`Created new bid for import ${dataId}. Schedule reveal... `);
+            Blockchain.bc.subscribeToEvent('RevealPhaseStarted', dataId)
+                .then((event) => {
+                    log.info(`Reveal phase started for ${dataId}`);
+                    Blockchain.bc.revealBid(
+                        dcWallet, dataId,
+                        config.identity, chosenPrice, stake, bid_index,
+                    )
+                        .then(() => {
+                            log.info(`Bid revealed for import ${dataId} and DC ${dcWallet}`);
+                        }).catch((err) => {
+                            log.warn(`Failed to reveal bid for import ${dataId} and DC ${dcWallet}. ${JSON.stringify(err)}`);
+                        });
+                }).catch((err) => {
+                    console.log(err);
+                });
 
-                                    DHService.scheduleRevealBid(
-                                        dcWallet, dataId, chosenPrice,
-                                        stake, bidIndex, totalEscrowTime,
-                                    );
-                                }).catch((err) => {
-                                    log.error(`Failed to insert new bid. ${err}`);
-                                });
-                                return true;
-                            }
-                        }
-                        return false;
-                    }, 5000, Date.now() + 20000);
+            Blockchain.bc.subscribeToEvent('OfferFinalized', dataId)
+                .then((event) => {
+                    Models.bids.findOne({ where: { data_id: dataId } }).then((bidModel) => {
+                        const bid = bidModel.get({ plain: true });
+                        node.ot.replicationRequest(
+                            {
+                                dataId,
+                                wallet: config.node_wallet,
+                            },
+                            bid.dc_id, (err) => {
+                                if (err) {
+                                    log.warn(`Failed to send replication request ${err}`);
+                                    // TODO Cancel bid here.
+                                }
+                            },
+                        );
+                    });
                 }).catch((err) => {
-                    log.error(err);
+                    console.log(err);
                 });
         } catch (e) {
             console.log(e);
         }
     }
 
+    static _saveBidToStorage(
+        event,
+        dcNodeId, chosenPrice, totalEscrowTime, stake, dataSizeBytes, dataId,
+    ) {
+        Models.bids.create({
+            bid_index: event.bidIndex,
+            price: chosenPrice.toString(),
+            data_id: dataId,
+            dc_wallet: event.DC_wallet,
+            dc_id: dcNodeId,
+            hash: event.bid_hash,
+            total_escrow_time: totalEscrowTime.toString(),
+            stake: stake.toString(),
+            data_size_bytes: dataSizeBytes.toString(),
+        }).then((bid) => {
+            log.info(`Created new bid for import ${dataId}. Waiting for reveal... `);
+        }).catch((err) => {
+            log.error(`Failed to insert new bid. ${err}`);
+        });
+    }
+
     static handleImport(data) {
         Models.bids.findOne({ where: { data_id: data.data_id } }).then((bidModel) => {
             // TODO: Check data before signing escrow.
@@ -144,140 +173,6 @@ class DHService {
             log.error(`Couldn't find bid with data ID ${data.data_id}. ${error}.`);
         });
     }
-
-    /**
-   * Schedule reveal before todtalEscrowTime
-   * @param dcWallet          DC wallet
-   * @param dataId            Data ID
-   * @param price             Price
-   * @param stake             Stake
-   * @param bidIndex          Bid indez
-   * @param totalEscrowTime   Total escrow time
-   * @private
-   */
-    static scheduleRevealBid(dcWallet, dataId, price, stake, bidIndex, totalEscrowTime) {
-        function revealBid(dcWallet, dataId, price, stake, bidIndex) {
-            Blockchain.bc.revealBid(dcWallet, dataId, config.identity, price, stake, bidIndex)
-                .then(() => {
-                    log.info(`Bid revealed for import ${dataId} and DC ${dcWallet}`);
-                    DHService.checkIfRevealed(dcWallet, dataId);
-                }).catch((err) => {
-                    log.warn(`Failed to reveal bid for import ${dataId} and DC ${dcWallet}. ${JSON.stringify(err)}`);
-                });
-        }
-        setTimeout(
-        // change time period in order to test reveal
-            revealBid, 65 * 1000,
-            dcWallet, dataId, price, stake, bidIndex,
-        );
-    }
-
-    /**
-   * Check whether bid has successfully been revealed
-   * @param dcWallet  DH wallet
-   * @param dataId    Data ID
-   */
-    static checkIfRevealed(dcWallet, dataId) {
-        Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'RevealedBid', {
-            fromBlock: 0,
-            toBlock: 'latest',
-        }, (data, err) => {
-            if (err) {
-                log.error(err);
-                return true;
-            }
-            // filter events manually since Web3 filtering is not working
-            for (const event of data) {
-                const eventDataId = event.returnValues.data_id;
-                const eventDcWallet = event.returnValues.DC_wallet;
-
-                if (Number(eventDataId) === dataId
-            && eventDcWallet === dcWallet) {
-                    log.info(`Successfully revealed bid for data ${dataId}.`);
-                    DHService.scheduleOfferFinalizedCheck(dataId, dcWallet);
-                    return true;
-                }
-            }
-            return false;
-        }, 5000, Date.now() + (15 * 60 * 1000));
-    }
-
-    /**
-   * Schedule check whether the offer is finalized or not
-   * @param dataId    Data ID
-   * @param dcWallet  DC wallet
-   */
-    static scheduleOfferFinalizedCheck(dataId, dcWallet) {
-        Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'OfferFinalized', {
-            fromBlock: 0,
-            toBlock: 'latest',
-        }, (data, err) => {
-            if (err) {
-                log.error(err);
-                return true;
-            }
-            // filter events manually since Web3 filtering is not working
-            for (const event of data) {
-                const eventDataId = event.returnValues.data_id;
-                const eventDcWallet = event.returnValues.DC_wallet;
-
-                if (Number(eventDataId) === dataId
-            && eventDcWallet === dcWallet) {
-                    log.info(`Offer for data ${dataId} successfully finalized. Check if the bid is chosen.`);
-                    DHService.scheduleBidChosenCheck(dataId, dcWallet);
-                    return true;
-                }
-            }
-            return false;
-        }, 5000, Date.now() + (15 * 60 * 1000));
-    }
-
-    /**
-   * Schedule check for whether the bid is chosed for the particular import
-   * @param dataId    Data ID
-   * @param dcWallet  DC wallet
-   */
-    static scheduleBidChosenCheck(dataId, dcWallet) {
-        Blockchain.bc.subscribeToEvent('BIDDING_CONTRACT', 'BidTaken', {
-            fromBlock: 0,
-            toBlock: 'latest',
-        }, (data, err) => {
-            if (err) {
-                log.error(err);
-                return true;
-            }
-            // filter events manually since Web3 filtering is not working
-            for (const event of data) {
-                const eventDataId = event.returnValues.data_id;
-                const eventDhWallet = event.returnValues.DH_wallet;
-                const eventDcWallet = event.returnValues.DC_wallet;
-
-                if (Number(eventDataId) === dataId
-            && eventDhWallet === config.node_wallet && eventDcWallet === dcWallet) {
-                    log.info(`The bid is chosen for DC ${dcWallet} and data ${dataId}`);
-
-                    Models.bids.findOne({ where: { data_id: dataId } }).then((bidModel) => {
-                        const bid = bidModel.get({ plain: true });
-                        node.ot.replicationRequest(
-                            {
-                                dataId,
-                                wallet: config.node_wallet,
-                            },
-                            bid.dc_id, (err) => {
-                                if (err) {
-                                    log.warn(`Failed to send replication request ${err}`);
-                                    // TODO Cancel bid here.
-                                }
-                            },
-                        );
-                    });
-
-                    return true;
-                }
-            }
-            return false;
-        }, 5000, Date.now() + (15 * 60 * 1000));
-    }
 }
 
 module.exports = DHService;
diff --git a/modules/EventHandlers.js b/modules/EventHandlers.js
index 63251dc..e70f5b3 100644
--- a/modules/EventHandlers.js
+++ b/modules/EventHandlers.js
@@ -14,6 +14,7 @@ const Utilities = require('./Utilities');
 const DHService = require('./DHService');
 const DCService = require('./DCService');
 const BN = require('bn.js');
+const Models = require('../models');
 
 const { globalEmitter } = globalEvents;
 const log = Utilities.getLogger();
@@ -104,7 +105,7 @@ globalEmitter.on('replication-request', (request, response) => {
         });
     });
 
-    response.send({ status: 'succes' });
+    response.send({ status: 'success' });
 });
 
 globalEmitter.on('payload-request', (request) => {
@@ -174,6 +175,9 @@ globalEmitter.on('offer-ended', (message) => {
     log.info(`Offer ${scId} has ended.`);
 });
 
+globalEmitter.on('AddedBid', (message) => {
+
+});
 
 globalEmitter.on('kad-bidding-won', (message) => {
     log.info('Wow I won bidding. Let\'s get into it.');
diff --git a/modules/Network.js b/modules/Network.js
index 971c7ef..f36a93f 100644
--- a/modules/Network.js
+++ b/modules/Network.js
@@ -104,10 +104,10 @@ class Network {
 
         // We use Hashcash for relaying messages to prevent abuse and make large scale
         // DoS and spam attacks cost prohibitive
-        node.ot.hashcash = node.ot.plugin(kadence.hashcash({
-            methods: ['PUBLISH', 'SUBSCRIBE', 'payload-sending'],
-            difficulty: 10,
-        }));
+        // node.ot.hashcash = node.ot.plugin(kadence.hashcash({
+        //     methods: ['PUBLISH', 'SUBSCRIBE', 'payload-sending'],
+        //     difficulty: 10,
+        // }));
         log.info('Hashcash initialised');
 
         if (parseInt(config.onion_enabled, 10)) {
@@ -347,6 +347,7 @@ class Network {
              * @param callback
              */
             node.replicationRequest = (message, contactId, callback) => {
+                // contactId = utilities.numberToHex(contactId).substring(2);
                 const contact = node.getContact(contactId);
                 node.send('replication-request', { message }, [contactId, contact], callback);
             };
diff --git a/modules/Utilities.js b/modules/Utilities.js
index be0f0ab..c00e859 100644
--- a/modules/Utilities.js
+++ b/modules/Utilities.js
@@ -237,10 +237,10 @@ class Utilities {
     }
 
     /**
-    * Generate Self Signed SSL for Kademlia
-    * @return {Promise<any>}
-    * @private
-    */
+     * Generate Self Signed SSL for Kademlia
+     * @return {Promise<any>}
+     * @private
+     */
     static generateSelfSignedCertificate() {
         return new Promise((resolve, reject) => {
             pem.createCertificate({
@@ -258,9 +258,9 @@ class Utilities {
     }
 
     /**
-    * Generates private extended key for identity
-    * @param kadence
-    */
+     * Generates private extended key for identity
+     * @param kadence
+     */
     static createPrivateExtendedKey(kadence) {
         if (!fs.existsSync(`${__dirname}/../keys/${config.private_extended_key_path}`)) {
             fs.writeFileSync(
diff --git a/ot-node.js b/ot-node.js
index 32b769e..0ac678b 100644
--- a/ot-node.js
+++ b/ot-node.js
@@ -53,6 +53,7 @@ class OTNode {
 
         // sync models
         Storage.models = deasync(models.sequelize.sync()).models;
+        Storage.db = models.sequelize;
 
         // Loading config data
         try {
@@ -133,6 +134,13 @@ class OTNode {
         }).catch((e) => {
             console.log(e);
         });
+
+        // Starting event listener on Blockchain
+        log.info('Starting blockchain event listener');
+        // BCInstance.bc.getAllPastEvents('BIDDING_CONTRACT');
+        setInterval(() => {
+            BCInstance.bc.getAllPastEvents('BIDDING_CONTRACT');
+        }, 3000);
     }
 
     /**
diff --git a/package.json b/package.json
index 82b4993..63dfdb5 100644
--- a/package.json
+++ b/package.json
@@ -79,9 +79,10 @@
     "sqlite3": "^4.0.0",
     "utf8-length": "latest",
     "validator": "^9.4.1",
-    "superagent": "^3.8.2",
+    "superagent": "^3.8.3",
     "web3": "^1.0.0-beta.33",
     "winston": "^2.4.1",
-    "xml2js": "^0.4.19"
+    "xml2js": "^0.4.19",
+    "utf8-length": "latest"
   }
 }
diff --git a/seeders/20180420143224-node-config.js b/seeders/20180420143224-node-config.js
index 1dd5895..1194001 100644
--- a/seeders/20180420143224-node-config.js
+++ b/seeders/20180420143224-node-config.js
@@ -3,7 +3,7 @@ require('dotenv').config();
 module.exports = {
     up: (queryInterface, Sequelize) => queryInterface.bulkInsert('node_config', [{
         key: 'dh_min_price',
-        value: '100',
+        value: '10',
     },
     {
         key: 'dh_max_price',
@@ -15,7 +15,7 @@ module.exports = {
     },
     {
         key: 'dh_max_stake',
-        value: '10000',
+        value: '1000',
     },
     ], {}),
     down: (queryInterface, Sequelize) => queryInterface.bulkDelete('node_config', null, {}),
-- 
2.13.5 (Apple Git-94)

