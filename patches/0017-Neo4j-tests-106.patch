From 7271a5055db02f605db040babdbda2780d898d07 Mon Sep 17 00:00:00 2001
From: Vuk Djoric <djoric.vuk@gmail.com>
Date: Mon, 7 May 2018 20:44:33 +0200
Subject: [PATCH 17/22] Neo4j tests (#106)

* implement Neo4J db support

* fix lint

* move some methods to Arango service

* move tests

* remove mocks

* remove invalid imports

* fix tests

* remove mocks

* fix array properties

* minor refactor

* remove unused methods

* neo4j constructor and seeders

* fix serialization

* fix session handling

* move method to Arango only

* fix lint

* fix fetch

* fix traversal path

* testovi

* package.json

* fix test

* fix tests

* fix vertex creation and add more tests

* traversalPath test

* add one more test

* removed file

* add Java8 and Neo4j installation steps

* working on neo4j installation

* change pass

* comment out test

* refactor tests

* fix test

* optimize sessions

* fix arangodb test

* refactor Neo4jDB

* fix session handling

* fix session handling in more methods

* remove explicit session passing

* close sessions explicitly

* added test

* fix promise execution ordering

* fix tests

* change query

* remove console logging

* remove more console logging

* fix static call

* fix param passing

* add more queries

* added tests

* fix test

* change pass

* add stringify to comparison

* refactor fetchVertex

* modify tests to use async/await

* temp skip one test

* comment out some tests

* return tests (trying to fix Travis)

* enable tests

* fix lint

* new tests

* new tests

* neo4j test update

* fix
---
 .env.example                         |   7 ++
 modules/Database/Neo4j.js            |  10 +--
 modules/Utilities.js                 |  78 +++++++++++++-------
 ot-node.js                           |  14 ++--
 test/modules/neo4j.test.js           | 131 +++++++++++++++++++++++----------
 test/modules/test_data/neo4j-data.js | 135 +++++++++++++++++++++++++++++++++++
 6 files changed, 303 insertions(+), 72 deletions(-)
 create mode 100644 test/modules/test_data/neo4j-data.js

diff --git a/.env.example b/.env.example
index 0980ee9..3c8c115 100644
--- a/.env.example
+++ b/.env.example
@@ -17,6 +17,13 @@ DB_PORT=8529
 DB_DATABASE=origintrail
 DB_HOST=localhost
 
+# GRAPH DATABASE / Neo4j
+NEO_USERNAME=neo4j
+NEO_PASSWORD=neo4j
+NEO_PORT=7687
+NEO_DATABASE=origintrail
+NEO_HOST=localhost
+
 # GENERAL SETTINGS
 IMPORT_WHITELIST=127.0.0.1
 
diff --git a/modules/Database/Neo4j.js b/modules/Database/Neo4j.js
index 169e5a5..f2caf6b 100644
--- a/modules/Database/Neo4j.js
+++ b/modules/Database/Neo4j.js
@@ -230,11 +230,11 @@ class Neo4jDB {
      * @param _key  Vertex _key
      * @return {Promise<void>}
      */
-    async getCurrentMaxVersion(uid, _key) {
+    async getCurrentMaxVersion(uid) {
         const session = this.driver.session();
-        const result = await session.run('MATCH (n) WHERE n.uid = $uid and n._key <> $_key return MAX(n.version)', { uid, _key });
+        const result = await session.run('MATCH (n)-[:CONTAINS]->(i) WHERE i.uid = $uid return MAX(n.version)', { uid });
         session.close();
-        return result;
+        return result.records[0]._fields[0];
     }
 
     /**
@@ -244,9 +244,9 @@ class Neo4jDB {
      */
     async getVertexKeyWithMaxVersion(uid) {
         const session = this.driver.session();
-        const result = await session.run('MATCH (n) WHERE n.uid = $uid RETURN n.version AS v ORDER BY v DESC LIMIT 1', { uid });
+        const result = await session.run('MATCH (n)-[:CONTAINS]->(i) WHERE i.uid = $uid RETURN n._key AS v ORDER BY v DESC LIMIT 1', { uid });
         session.close();
-        return result;
+        return result.records[0]._fields[0];
     }
 
     /**
diff --git a/modules/Utilities.js b/modules/Utilities.js
index c00e859..ac98f54 100644
--- a/modules/Utilities.js
+++ b/modules/Utilities.js
@@ -11,6 +11,7 @@ const randomString = require('randomstring');
 const Web3 = require('web3');
 const request = require('superagent');
 const { Database } = require('arangojs');
+const neo4j = require('neo4j-driver').v1;
 
 require('dotenv').config();
 
@@ -182,38 +183,63 @@ class Utilities {
     }
 
     /**
-     * Check does origintrail database exists, otherwise create one
+     * Check if origintrail database exists, in case of arangoDB create one
      * @returns {Promise<any>}
      */
     static checkDoesStorageDbExists() {
         return new Promise((resolve, reject) => {
-            const systemDb = new Database();
-            systemDb.useBasicAuth(process.env.DB_USERNAME, process.env.DB_PASSWORD);
-            systemDb.listDatabases().then((result) => {
-                let databaseAlreadyExists = false;
-                for (let i = 0; i < result.length; i += 1) {
-                    if (result[i].toString() === process.env.DB_DATABASE) {
-                        databaseAlreadyExists = true;
+            switch (config.database.database_system) {
+            case 'arango_db': {
+                const systemDb = new Database();
+                systemDb.useBasicAuth(process.env.DB_USERNAME, process.env.DB_PASSWORD);
+                systemDb.listDatabases().then((result) => {
+                    let databaseAlreadyExists = false;
+                    for (let i = 0; i < result.length; i += 1) {
+                        if (result[i].toString() === process.env.DB_DATABASE) {
+                            databaseAlreadyExists = true;
+                        }
                     }
+                    if (!databaseAlreadyExists) {
+                        systemDb.createDatabase(
+                            process.env.DB_DATABASE,
+                            [{
+                                username: process.env.DB_USERNAME,
+                                passwd: process.env.DB_PASSWORD,
+                                active: true,
+                            }],
+                        ).then((result) => {
+                            resolve();
+                        }).catch((error) => {
+                            reject(error);
+                        });
+                    }
+                    resolve();
+                }).catch((error) => {
+                    reject(error);
+                });
+            }
+                break;
+            case 'neo4j':
+                try {
+                    // TODO
+                    const host = process.env.NEO_HOST;
+                    const port = process.env.NEO_PORT;
+                    const user = process.env.NEO_USERNAME;
+                    const pass = process.env.NEO_PASSWORD;
+                    const driver = neo4j.driver(`bolt://${host}:${port}`, neo4j.auth.basic(user, 'nijePASS'));
+                    const session = driver.session();
+                    const a = session.run('match (n) return n');
+                    session.close();
+                    driver.close();
+                    resolve();
+                } catch (error) {
+                    reject(error);
                 }
-                if (!databaseAlreadyExists) {
-                    systemDb.createDatabase(
-                        process.env.DB_DATABASE,
-                        [{
-                            username: process.env.DB_USERNAME,
-                            passwd: process.env.DB_PASSWORD,
-                            active: true,
-                        }],
-                    ).then((result) => {
-                        resolve();
-                    }).catch((error) => {
-                        reject(error);
-                    });
-                }
-                resolve();
-            }).catch((error) => {
-                reject(error);
-            });
+                break;
+            default:
+                this.getLogger.error(config.database.database_system);
+                reject(Error('Database doesn\'t exists'));
+            }
         });
     }
 
diff --git a/ot-node.js b/ot-node.js
index 0ac678b..1ed4700 100644
--- a/ot-node.js
+++ b/ot-node.js
@@ -41,9 +41,7 @@ class OTNode {
             // check if all dependencies are installed
             deasync(Utilities.checkInstalledDependencies());
             log.info('npm modules dependences check done');
-            // make sure arango database exists
-            deasync(Utilities.checkDoesStorageDbExists());
-            log.info('Storage database check done');
+
             // Checking root folder stucture
             Utilities.checkOtNodeDirStructure();
             log.info('ot-node folder structure check done');
@@ -73,8 +71,16 @@ class OTNode {
             console.log(err);
         }
 
+        // Checking if selected graph database exists
+        try {
+            deasync(Utilities.checkDoesStorageDbExists());
+            log.info('Storage database check done');
+        } catch (err) {
+            console.log(err);
+        }
+
         let selectedBlockchain;
-        // Loading selected graph database data
+        // Loading selected blockchain network
         try {
             selectedBlockchain = deasync(Utilities.loadSelectedBlockchainInfo());
             log.info(`Loaded selected blockchain network ${selectedBlockchain.blockchain_title}`);
diff --git a/test/modules/neo4j.test.js b/test/modules/neo4j.test.js
index 1ff5835..764cef1 100644
--- a/test/modules/neo4j.test.js
+++ b/test/modules/neo4j.test.js
@@ -2,10 +2,20 @@ const {
     describe, before, after, it, afterEach,
 } = require('mocha');
 const { assert, expect } = require('chai');
-const stringify = require('json-stable-stringify');
 
 const Neo4j = require('../../modules/Database/Neo4j.js');
-const databaseData = require('./test_data/database-data.js');
+const databaseData = require('./test_data/neo4j-data.js');
+
+const vertices = [
+    { data: 'A', _key: '100' },
+    { data: 'B', _key: '101' },
+    { data: 'C', _key: '102' },
+    { data: 'D', _key: '103' }];
+const edges = [
+    { edgeType: 'IS', _from: '100', _to: '101' },
+    { edgeType: 'IS', _from: '101', _to: '102' },
+    { edgeType: 'IS', _from: '102', _to: '103' },
+    { edgeType: 'IS', _from: '101', _to: '103' }];
 
 const myUsername = 'neo4j';
 const myPassword = 'neo4j';
@@ -15,6 +25,8 @@ const port = '7687';
 
 const vertexOne = databaseData.vertices[0];
 const vertexTwo = databaseData.vertices[1];
+const vertexOneV2 = databaseData.vertices[2];
+const vertexOneV3 = databaseData.vertices[3];
 
 const edgeOne = databaseData.edges[0];
 
@@ -22,8 +34,6 @@ let testDb;
 
 describe('Neo4j module ', async () => {
     before('create and use testDb db', async () => {
-        // TODO kreirati novu bazu
-
         testDb = new Neo4j(myUsername, myPassword, myDatabaseName, host, port);
     });
 
@@ -36,26 +46,40 @@ describe('Neo4j module ', async () => {
             assert.equal(err.message, 'Invalid vertex null');
         });
     });
+
     it('pass empty for vertex', async () => {
         await testDb.addDocument('ot_vertices', {}).catch((err) => {
             assert.equal(err.message, 'Invalid vertex {}');
         });
     });
+
     it('pass regular for vertex', async () => {
-        await testDb.addDocument('ot_vertices', vertexOne);
-        const result = await testDb.findVertices({ _key: vertexOne._key });
-        assert.equal(stringify(vertexOne), stringify(result[0]));
+        await testDb.addDocument('ot_vertices', vertexOne).then(() => {
+            testDb.findVertices({ _key: vertexOne._key }).then((result) => {
+                assert.deepEqual(vertexOne, result[0]);
+            });
+        });
     });
+
+    it('.findVertices() with non existing vertex should find nothing', async () => {
+        const queryObject = {
+            vertex_key: 'none',
+        };
+        await testDb.findVertices(queryObject).then((response) => {
+            assert.isEmpty(response);
+            assert.isTrue(typeof (response) === 'object');
+        });
+    });
+
     it('.findTraversalPath() with regular vertices', async () => {
-        await testDb.addDocument('ot_vertices', vertexOne);
         await testDb.addDocument('ot_vertices', vertexTwo);
         await testDb.addDocument('ot_edges', edgeOne);
 
-        const path = await testDb.findTraversalPath(vertexOne, 2);
+        const path = await testDb.findTraversalPath(vertexOne, 1);
         assert.equal(path.length, 2);
     });
 
-    it('.findTraversalPath() non existing starting vertex', async () => {
+    it('.findTraversalPath() with non existing starting vertex', async () => {
         const startVertex = {
             _key: '-1',
         };
@@ -64,50 +88,83 @@ describe('Neo4j module ', async () => {
         assert.equal(path, '');
     });
 
-    it('.findTraversalPath() less than max length', async () => {
-        const vertices = [{ data: 'A', _key: '100' }, { data: 'B', _key: '101' }, { data: 'C', _key: '102' }];
-        const edges = [{ edgeType: 'IS', _from: '100', _to: '101' }, { edgeType: 'IS', _from: '101', _to: '102' }];
-
+    it('.findTraversalPath() with depth less than max length', async () => {
         await testDb.addDocument('ot_vertices', vertices[0]);
         await testDb.addDocument('ot_vertices', vertices[1]);
         await testDb.addDocument('ot_vertices', vertices[2]);
+        await testDb.addDocument('ot_vertices', vertices[3]);
         await testDb.addDocument('ot_edges', edges[0]);
         await testDb.addDocument('ot_edges', edges[1]);
+        await testDb.addDocument('ot_edges', edges[2]);
 
-        const path = await testDb.findTraversalPath({ _key: '100' }, 1);
-        assert.equal(path.length, 2);
+        const path = await testDb.findTraversalPath({ _key: '100' }, 2);
+        console.log(path);
+        assert.equal(path.length, 3);
     });
 
     it('.findTraversalPath() with max length', async () => {
-        const vertices = [
-            { data: 'A', _key: '100' },
-            { data: 'B', _key: '101' },
-            { data: 'C', _key: '102' },
-            { data: 'D', _key: '103' }];
-        const edges = [
-            { edgeType: 'IS', _from: '100', _to: '101' },
-            { edgeType: 'IS', _from: '101', _to: '102' },
-            { edgeType: 'IS', _from: '102', _to: '103' },
-            { edgeType: 'IS', _from: '101', _to: '103' }];
+        const path = await testDb.findTraversalPath({ _key: '100' }, 1000);
+        assert.equal(path.length, 4);
+    });
 
-        await testDb.addDocument('ot_vertices', vertices[0]);
-        await testDb.addDocument('ot_vertices', vertices[1]);
-        await testDb.addDocument('ot_vertices', vertices[2]);
-        await testDb.addDocument('ot_vertices', vertices[3]);
-        await testDb.addDocument('ot_edges', edges[0]);
-        await testDb.addDocument('ot_edges', edges[1]);
-        await testDb.addDocument('ot_edges', edges[2]);
+    it('traversal path with interconnected vertices', async () => {
         await testDb.addDocument('ot_edges', edges[3]);
 
-        const path = await testDb.findTraversalPath({ _key: '100' }, 10);
-        assert.equal(path.length, 4);
+        const path = await testDb.findTraversalPath({ _key: '100' }, 1000);
+
+        console.log(JSON.stringify(path));
     });
 
-    afterEach('clear testDb db', async () => {
-        await testDb.clear();
+    it('getCurrentMaxVersion single version vertex', async () => {
+        // vertexTwo has one version
+        const response = await testDb.getCurrentMaxVersion(vertexTwo.identifiers.uid);
+        assert.equal(response, 1);
+    });
+
+    it('getCurrentMaxVersion vertex has multiple versions', async () => {
+        // vertexOne has three versions
+        await testDb.addDocument('ot_vertices', vertexOneV2);
+        await testDb.addDocument('ot_vertices', vertexOneV3);
+        const response = await testDb.getCurrentMaxVersion(vertexOne.identifiers.uid);
+        assert.equal(response, 3);
+    });
+
+    it('getVertexKeyWithMaxVersion', async () => {
+        const response = await testDb.getVertexKeyWithMaxVersion(vertexOne.identifiers.uid);
+        console.log(response);
+    });
+
+    it('getVerticesByImportId', async () => {
+        const response = await testDb.getVerticesByImportId('1520345631');
+
+        function sortByKey(a, b) {
+            if (a._key < b._key) {
+                return -1;
+            }
+            if (a._key > b._key) {
+                return 1;
+            }
+            return 0;
+        }
+
+        assert.deepEqual(databaseData.vertices.sort(sortByKey), response.sort(sortByKey));
+    });
+
+    it('update document imports', async () => {
+        await testDb.updateDocumentImports('ot_vertices', vertexOne, 101100);
+        const response = await testDb.getVerticesByImportId(101100);
+
+        assert.deepEqual(response[0].data, vertexOne.data);
+        assert.deepEqual(response[0].vertex_type, vertexOne.vertex_type);
+        assert.deepEqual(response[0].identifiers, vertexOne.identifiers);
+        assert.deepEqual(response[0].vertex_key, vertexOne.vertex_key);
+        assert.deepEqual(response[0]._key, vertexOne._key);
+        assert.deepEqual(response[0].imports, [vertexOne.imports[0], 101100]);
+        assert.deepEqual(response[0].data_provider, vertexOne.data_provider);
     });
 
     after('drop testDb db', async () => {
+        await testDb.clear();
         testDb.close();
     });
 });
diff --git a/test/modules/test_data/neo4j-data.js b/test/modules/test_data/neo4j-data.js
new file mode 100644
index 0000000..9c44f8a
--- /dev/null
+++ b/test/modules/test_data/neo4j-data.js
@@ -0,0 +1,135 @@
+const databaseData = {};
+
+databaseData.vertices = [{
+    data: {
+        BusinessLocationName: {
+            EN: "Partner's Farm",
+        },
+        BusinessLocationType: 'Farm',
+        Location: {
+            Address: "Farmer's Street 01B",
+            City: 'Bytesfield',
+            Country: 'Cryptonia',
+            GeoLocation: {
+                Latitude: '00.0000',
+                Longitude: '00.0000',
+            },
+            Zip: '20000',
+        },
+    },
+    vertex_type: 'BUSINESS_LOCATION',
+    identifiers: {
+        BusinessLocationId: 'FARM_1',
+        uid: 'ot:WALLET_ID:otblid:FARM_1',
+    },
+    vertex_key: '2e0b1ba163be76138d51a0b8258e97d7',
+    _key: '2e0b1ba163be76138d51a0b8258e97d7',
+    imports: [
+        1520345631,
+    ],
+    data_provider: 'WALLET_ID',
+    version: 1,
+},
+
+{
+    data: {
+        Location: {
+            Address: "Farmer's Street 01B",
+            City: 'Bytesfield',
+            Country: 'Cryptonia',
+            GeoLocation: {
+                Latitude: '00.0000',
+                Longitude: '00.0000',
+            },
+            Zip: '20000',
+        },
+        Name: {
+            EN: 'Partner',
+        },
+    },
+    vertex_type: 'PARTICIPANT',
+    identifiers: {
+        ParticipantId: 'PARTNER_ID',
+        uid: 'ot:WALLET_ID:otpartid:PARTNER_ID',
+    },
+    vertex_key: 'cd923bec4266a7f63b68722da254f205',
+    _key: 'cd923bec4266a7f63b68722da254f205',
+    imports: [1520345631],
+    version: 1,
+},
+
+{
+    data: {
+        BusinessLocationName: {
+            EN: "Partner's Farm",
+        },
+        BusinessLocationType: 'Farm',
+        Location: {
+            Address: "Farmer's Street 01B",
+            City: 'Bytesfield',
+            Country: 'Cryptonia',
+            GeoLocation: {
+                Latitude: '00.0000',
+                Longitude: '00.0000',
+            },
+            Zip: '20000',
+        },
+    },
+    vertex_type: 'BUSINESS_LOCATION',
+    identifiers: {
+        BusinessLocationId: 'FARM_1',
+        uid: 'ot:WALLET_ID:otblid:FARM_1',
+    },
+    vertex_key: '2e0b1ba163be76138d51a0b8258e97d7',
+    _key: '2e0b1ba163be76138d51a0b8258e97d8',
+    imports: [
+        1520345631,
+    ],
+    data_provider: 'WALLET_ID',
+    version: 2,
+},
+
+{
+    data: {
+        BusinessLocationName: {
+            EN: "Partner's Farm",
+        },
+        BusinessLocationType: 'Farm',
+        Location: {
+            Address: "Farmer's Street 01B",
+            City: 'Bytesfield',
+            Country: 'Cryptonia',
+            GeoLocation: {
+                Latitude: '00.0000',
+                Longitude: '00.0000',
+            },
+            Zip: '20000',
+        },
+    },
+    vertex_type: 'BUSINESS_LOCATION',
+    identifiers: {
+        BusinessLocationId: 'FARM_1',
+        uid: 'ot:WALLET_ID:otblid:FARM_1',
+    },
+    vertex_key: '2e0b1ba163be76138d51a0b8258e97d7',
+    _key: '2e0b1ba163be76138d51a0b8258e97d9',
+    imports: [
+        1520345631,
+    ],
+    data_provider: 'WALLET_ID',
+    version: 3,
+},
+];
+
+databaseData.edges = [
+    {
+        _key: '6eb743d84a605b2ab6be67a373b883d4',
+        edge_type: 'OWNED_BY',
+        data_provider: 'WALLET_ID',
+        imports: [1520345631],
+        _from: 'ot_vertices/2e0b1ba163be76138d51a0b8258e97d7',
+        _to: 'ot_vertices/cd923bec4266a7f63b68722da254f205',
+    },
+];
+
+module.exports = databaseData;
-- 
2.13.5 (Apple Git-94)

